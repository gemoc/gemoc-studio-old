import fr.inria.aoste.timesquare.ecl.EclQVToHelper;
 
	
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
//modeltype pivot uses 'http://www.eclipse.org/ocl/3.1.0/Pivot';
modeltype inMM uses 'http://www.gemoc.org/sample/tfsm';
modeltype QVT uses 'http://www.eclipse.org/QVT/1.0.0/Operational';//http://www.eclipse.org/m2m/qvt/oml/1.0.0/Stdlib';//http://www.eclipse.org/qvt/1.0/ImperativeOCL'; 
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';

	

transformation dotfsm_ecore_To_CCSL(in inM : inMM, out TimeModel);

property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;

property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;

property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};


query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.gemoc.sample.tfsm.moc.lib/ccsl/TFSMMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.gemoc.sample.tfsm.moc.lib/ccsl/TFSMMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.gemoc.sample.tfsm.moc.lib/ccsl/TFSMMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.gemoc.sample.tfsm.moc.lib/ccsl/TFSMMoC.ccslLib")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM::TimedSystem]->asSequence()->first()-> map tfsm2CCSL();
	}

			
			

	mapping inMM::TimedSystem::tfsm2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := self.name;
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;

		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.gemoc.sample.tfsm.moc.lib/ccsl/TFSMMoC.ccslLib';
			alias := 'TFSMMoC';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		inM.rootObjects().allSubobjects()->including(self)[ FSMClock ]->map ticks2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map fire2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ EvaluateGuard ]->map evaluate2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ FSMEvent ]->map occurs2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ State ]->map entering2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ State ]->map leaving2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ EvaluateGuard ]->map evaluatedTrue2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ EvaluateGuard ]->map evaluatedFalse2Clock();
		


		

		inM.rootObjects().allSubobjects()->including(self)[ TFSM ]->map start2Clock();
		inM.rootObjects().allSubobjects()->including(self)[ TFSM ]->map stall2Clock();
		


		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ FSMEvent ]->map occursWhenSolicitate212occursWhenSolicitate();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map fireWhenRestrueOccursTransition502fireWhenRestrueOccursTransition();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map fireWhenRestrueOccursVariousTransition512fireWhenRestrueOccursVariousTransition();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map fireWhenEventOccursOneTransition522fireWhenEventOccursOneTransition();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map fireWhenEventOccursVariousTransition512fireWhenEventOccursVariousTransition();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map fireWhenTemporalGuardHoldsVariousTransition632fireWhenTemporalGuardHoldsVariousTransition();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map fireWhenTemporalGuardHoldsOneTransition652fireWhenTemporalGuardHoldsOneTransition();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ Transition ]->map EvaluateGuardWhenEnteringState122EvaluateGuardWhenEnteringState();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ State ]->map enterOnceBeforeToLeave12enterOnceBeforeToLeave();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ State ]->map firingATransitionAlternatesWithLeavingState102firingATransitionAlternatesWithLeavingState();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ State ]->map stateEntering232stateEntering();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ EvaluateGuard ]->map fireEvaluationAndResult12fireEvaluationAndResult();
		
		

		


		
		inM.rootObjects().allSubobjects()->including(self)[ TFSM ]->map oneStateAtATime12oneStateAtATime();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ TFSM ]->map oneTransitionAtATime12oneTransitionAtATime();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ TFSM ]->map firstIsInitialState12firstIsInitialState();
		
		
		inM.rootObjects().allSubobjects()->including(self)[ TFSM ]->map firstOnlyOnce82firstOnlyOnce();
		
	}





//create the expressions...
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::FSMEvent::intermediate_AllTriggeringOccurrences2Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_AllTriggeringOccurrences'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::FSMEvent::intermediate_AllTriggeringOccurrences2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_AllTriggeringOccurrences'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_fire']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::FSMEvent::AllTriggeringOccurrences2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.sollicitingTransitions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_AllTriggeringOccurrences2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_AllTriggeringOccurrences2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_AllTriggeringOccurrences2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Transition::restrueOccursAfterOrWhileStateEntering2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_SampledOn_restrueOccursAfterOrWhileStateEntering';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedGuard.oclAsType(EvaluateGuard).name+'_evaluatedTrue']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnTrigger' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Transition::intermediate_otherFireFromTheSameState32Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_otherFireFromTheSameState3'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Transition::intermediate_otherFireFromTheSameState32Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_otherFireFromTheSameState3'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_fire']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Transition::otherFireFromTheSameState32Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.source.outgoingTransitions->select(t | (t) <> self)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_otherFireFromTheSameState32Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_otherFireFromTheSameState32Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_otherFireFromTheSameState32Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Transition::eventOccursAfterOrWhileStateEntering2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_SampledOn_eventOccursAfterOrWhileStateEntering';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedGuard.oclAsType(EventGuard).triggeringEvent.name+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnTrigger' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Transition::intermediate_otherFireFromTheSameState22Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_otherFireFromTheSameState2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Transition::intermediate_otherFireFromTheSameState22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_otherFireFromTheSameState2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_fire']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Transition::otherFireFromTheSameState22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.source.outgoingTransitions->select(t| (t) <> self)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_otherFireFromTheSameState22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_otherFireFromTheSameState22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_otherFireFromTheSameState22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::Transition::intermediate_otherFireFromTheSameState2Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_otherFireFromTheSameState'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Transition::intermediate_otherFireFromTheSameState2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_otherFireFromTheSameState'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_fire']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::Transition::otherFireFromTheSameState2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.source.outgoingTransitions->select(t| (t) <> self)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_otherFireFromTheSameState2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_otherFireFromTheSameState2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_otherFireFromTheSameState2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::Transition::delayIsExpired_wrt_StateEntering2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'_DelayFor_delayIsExpired_wrt_StateEntering';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "DelayFor")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockToDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedGuard.oclAsType(TemporalGuard).onClock.name+'_ticks']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockForCounting' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self.ownedGuard.oclAsType(TemporalGuard).afterDuration -> map Real2Integer(self.name+self.ownedGuard.oclAsType(TemporalGuard).name+"_afterDuration")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::State::intermediate_allFiredoutgoingTransition2Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_allFiredoutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::State::intermediate_allFiredoutgoingTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_allFiredoutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_fire']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::State::allFiredoutgoingTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.outgoingTransitions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allFiredoutgoingTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allFiredoutgoingTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allFiredoutgoingTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::State::intermediate_allInputTransition2Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_fire']->first();
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::State::intermediate_allInputTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					 _abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an.name+'_fire']->first();
					
					_abstract := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::State::allInputTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.incomingTransitions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allInputTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM::TFSM::intermediate_onlyOneFirst2Expression(an1 : TFSM, an2 : TFSM, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := self.name+'intermediate_onlyOneFirst'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'OneTickAndNoMoreClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'OneTickAndNoMore']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM::TFSM::intermediate_onlyOneFirst2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TFSM, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := self.name+'intermediate_onlyOneFirst'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					_abstract := seqOfExpressionDeclaration[name = 'OneTickAndNoMore']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);									};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM::TFSM::onlyOneFirst2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TFSM) := self->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_onlyOneFirst2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_onlyOneFirst2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_onlyOneFirst2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}





	 	mapping inMM::FSMClock::ticks2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_ticks';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += inMM::FSMClock.oclAsType(EClass).eAllOperations->select(op |op.name = "ticks")->first().oclAsType(EObject);
			
				name := 'evt_'+self.name+'_ticks';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::Transition::fire2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_fire';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += inMM::Transition.oclAsType(EClass).eAllOperations->select(op |op.name = "fire")->first().oclAsType(EObject);
			
				name := 'evt_'+self.name+'_fire';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::EvaluateGuard::evaluate2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_evaluate';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += inMM::EvaluateGuard.oclAsType(EClass).eAllOperations->select(op |op.name = "evaluate")->first().oclAsType(EObject);
			
				name := 'evt_'+self.name+'_evaluate';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::FSMEvent::occurs2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_occurs';
			tickingEvent := object TimeModel::Event{
			
				name := 'evt_'+self.name+'_occurs';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::State::entering2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_entering';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+self.name+'_entering';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM::State::leaving2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_leaving';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+self.name+'_leaving';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::EvaluateGuard::evaluatedTrue2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_evaluatedTrue';
			tickingEvent := object TimeModel::Event{
			
				name := 'evt_'+self.name+'_evaluatedTrue';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM::EvaluateGuard::evaluatedFalse2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_evaluatedFalse';
			tickingEvent := object TimeModel::Event{
			
				name := 'evt_'+self.name+'_evaluatedFalse';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM::TFSM::start2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_start';
			tickingEvent := object TimeModel::Event{
			
				name := 'evt_'+self.name+'_start';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM::TFSM::stall2Clock() :TimeModel::Clock 
		{
			name:= self.name+'_stall';
			tickingEvent := object TimeModel::Event{
			
				name := 'evt_'+self.name+'_stall';
				kind := TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM::FSMEvent::occursWhenSolicitate212occursWhenSolicitate(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.sollicitingTransitions->size() >0) 
				
}
		{
		 	name := self.name+"FSMEventSendReceive_occursWhenSolicitate";
			type := seqOfRelationDeclaration->select(rd | rd.name = "FSMEventSendReceive")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map AllTriggeringOccurrences2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'FSMEventRendezVous_LeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'FSMEventRendezVous_RightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::Transition::fireWhenRestrueOccursTransition502fireWhenRestrueOccursTransition(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard.oclIsKindOf(EvaluateGuard) and self.source.outgoingTransitions->select(t | (t) <> self)->size() = 0) 
				
}
		{
		 	name := self.name+"Coincides_fireWhenRestrueOccursTransition";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map restrueOccursAfterOrWhileStateEntering2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_fire']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Transition::fireWhenRestrueOccursVariousTransition512fireWhenRestrueOccursVariousTransition(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard.oclIsKindOf(EvaluateGuard) and self.source.outgoingTransitions->select(t | (t) <> self)->size() > 0) 
				
}
		{
		 	name := self.name+"EventTransition_fireWhenRestrueOccursVariousTransition";
			type := seqOfRelationDeclaration->select(rd | rd.name = "EventTransition")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_MakeFireable']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedGuard.oclAsType(EvaluateGuard).name+'_evaluatedTrue']->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_Trigger']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map otherFireFromTheSameState32Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_Reset']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_fire']->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_Fire']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Transition::fireWhenEventOccursOneTransition522fireWhenEventOccursOneTransition(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard.oclIsKindOf(EventGuard) and self.source.outgoingTransitions->select(t| (t) <> self)->size() = 0) 
				
}
		{
		 	name := self.name+"Coincides_fireWhenEventOccursOneTransition";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map eventOccursAfterOrWhileStateEntering2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_fire']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Transition::fireWhenEventOccursVariousTransition512fireWhenEventOccursVariousTransition(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard.oclIsKindOf(EventGuard) and self.source.outgoingTransitions->select(t| (t) <> self)->size() > 0) 
				
}
		{
		 	name := self.name+"EventTransition_fireWhenEventOccursVariousTransition";
			type := seqOfRelationDeclaration->select(rd | rd.name = "EventTransition")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_MakeFireable']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedGuard.oclAsType(EventGuard).triggeringEvent.name+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_Trigger']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map otherFireFromTheSameState22Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_Reset']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_fire']->first();
					_abstract := seqOfAbstractEntity[name = 'EventTransition_Fire']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Transition::fireWhenTemporalGuardHoldsVariousTransition632fireWhenTemporalGuardHoldsVariousTransition(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard.oclIsKindOf(TemporalGuard) and self.source.outgoingTransitions->select(t| (t) <> self)->size() > 0) 
				
}
		{
		 	name := self.name+"TemporalTransition_fireWhenTemporalGuardHoldsVariousTransition";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TemporalTransition")->first();
					var guardDelay : Integer := self.ownedGuard.oclAsType(TemporalGuard).afterDuration;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'TemporalTransition_MakeFireable']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedGuard.oclAsType(TemporalGuard).onClock.name+'_ticks']->first();
					_abstract := seqOfAbstractEntity[name = 'TemporalTransition_RefClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map otherFireFromTheSameState2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'TemporalTransition_Reset']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self.ownedGuard.oclAsType(TemporalGuard).afterDuration -> map Real2Integer(self.name+self.ownedGuard.oclAsType(TemporalGuard).name+"guardDelay"+"_afterDuration")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'TemporalTransition_delay']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_fire']->first();
					_abstract := seqOfAbstractEntity[name = 'TemporalTransition_Fire']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Transition::fireWhenTemporalGuardHoldsOneTransition652fireWhenTemporalGuardHoldsOneTransition(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard.oclIsKindOf(TemporalGuard) and self.source.outgoingTransitions->select(t| (t) <> self)->size() = 0) 
				
}
		{
		 	name := self.name+"Coincides_fireWhenTemporalGuardHoldsOneTransition";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var delay : Integer := self.ownedGuard.oclAsType(TemporalGuard).afterDuration;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map delayIsExpired_wrt_StateEntering2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_fire']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::Transition::EvaluateGuardWhenEnteringState122EvaluateGuardWhenEnteringState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard.oclIsKindOf(EvaluateGuard)) 
				
}
		{
		 	name := self.name+"Coincides_EvaluateGuardWhenEnteringState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.ownedGuard.oclAsType(EvaluateGuard).name+'_evaluate']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.source.name+'_entering']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::State::enterOnceBeforeToLeave12enterOnceBeforeToLeave(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Alternates_enterOnceBeforeToLeave";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::State::firingATransitionAlternatesWithLeavingState102firingATransitionAlternatesWithLeavingState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_firingATransitionAlternatesWithLeavingState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map allFiredoutgoingTransition2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_leaving']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::State::stateEntering232stateEntering(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(not (self = self.owningFSM.initialState)) 
				
}
		{
		 	name := self.name+"Causes_stateEntering";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map allInputTransition2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_entering']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM::EvaluateGuard::fireEvaluationAndResult12fireEvaluationAndResult(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"TransitionRule_fireEvaluationAndResult";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TransitionRule")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_evaluate']->first();
					_abstract := seqOfAbstractEntity[name = 'evaluateGuard']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_evaluatedTrue']->first();
					_abstract := seqOfAbstractEntity[name = 'resTrue']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_evaluatedFalse']->first();
					_abstract := seqOfAbstractEntity[name = 'resFalse']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	

//Create an intermediate relation
	mapping inMM::TFSM::intermediate_oneStateAtATime12oneStateAtATime(an1 : State, an2 : State, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := self.name+'intermediate_oneStateAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_entering']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_entering']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM::TFSM::oneStateAtATime12oneStateAtATime()
	{
		init{
			var sources : Sequence(State) := self.ownedStates->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneStateAtATime12oneStateAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	

//Create an intermediate relation
	mapping inMM::TFSM::intermediate_oneTransitionAtATime12oneTransitionAtATime(an1 : Transition, an2 : Transition, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := self.name+'intermediate_oneTransitionAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an1.name+'_fire']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = an2.name+'_fire']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM::TFSM::oneTransitionAtATime12oneTransitionAtATime()
	{
		init{
			var sources : Sequence(Transition) := self.ownedStates.outgoingTransitions->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneTransitionAtATime12oneTransitionAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM::TFSM::firstIsInitialState12firstIsInitialState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_firstIsInitialState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.initialState.name+'_entering']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM::TFSM::firstOnlyOnce82firstOnlyOnce(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := self.name+"Coincides_firstOnlyOnce";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = self.name+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				
						bindable := self -> map onlyOneFirst2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

